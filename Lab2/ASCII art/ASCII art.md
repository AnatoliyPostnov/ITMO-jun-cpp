В данной работе необходимо разработать программу для рисования ASCII символами.
Класс Canvas создает основу состоящую из "пикселей" для рисования ASCII арта.
"Пиксели" соответственно можно включать и выключать.
Необходимо создать класс для рисования примитивов. Класс Shape будет являться базовым для всех остальных примитивов.

Программа должна состоят из следующих файлов:
- Canvas.h
- Canvas.cpp
- shapes.h
- shapes.cpp
- Lab02.cpp

Задания:
- Реализовать класс Circle для рисования круга
- Реализовать класс Ellipse для рисования эллипсов и сделать класс Circle наследником класса Ellipse. Никакие методы не должны быть перегружены.
- Реализовать класс Rectangle для рисования прямоугольника
- Класс Rectangle должен наследоваться от класса Shape. Необходимо перегрузить методы area и draw.
    
Для компиляции программы целиком:
 
```bash
g++ -Wall -Werror -01 --std=c++1 -pedantic Canvas.cpp shapes.cpp lab02.cpp -o lab02
```

Перед выполнением работы необходимо ознакомиться с файлами-заголовочниками 
Canvas.h и shapes.h, файлы содержат всю необходимую информацию.

 #----------------------------------------------------------
 
**Canvas** 
Canvas представляет 2D изображение и поддерживает следующие операции:

```cpp
/**
Базовая операция для работы с изображением. Пиксель может быть выставлен в положение "Вкл"(true) или "Выкл"(false). При создании экземпляра Canvas все пиксели находятся в состоянии "Выкл".
*/
void setPixel(int x, int y, bool value)

/* Выводит в консоль текущее состояние Canvas. */
void print() const

```
**Предисловие**

**Shape**

Shape служит для представления геометрических примитивов и является абстрактным классом, от этого класса будут наследоваться все производные формы.
Описание класса Space:

```cpp
class Shape {
public:

  //EFFECTS: создает примитив с начальной точкой (0,0)
  Shape() : xPos(0), yPos(0) {}

  //EFFECTS: возвращает площадь примитива
  virtual double area() const = 0;

  //MODIFIES: canvas
  //EFFECTS: рисует примитив на сетке относительно текущей начальной точки
  virtual void draw(Canvas *canvas) const = 0;

  //MODIFIES: xPos, yPos
  //EFFECTS: устанавливает начальную точку для отрисовки примитива
  void setPosition(double xPos_in, double yPos_in){
    xPos = xPos_in;
    yPos = yPos_in;
  }

  double get_xPos() const { return xPos; }
  double get_yPos() const { return yPos; }

private:

  double xPos; // The x position of this shape
  double yPos; // The y position of this shape

};
```

Функции area() и draw() должны быть реализованы в наследуемом классе. Обе функции объявлены виртуальными.  Виртуальная функция — это функция, объявленная с ключевым словом virtual в базовом классе и переопределенная в одном или в нескольких производных классах. Виртуальные функции являются особыми функциями, потому что при вызове объекта производного класса с помощью указателя или ссылки на него С++ определяет во время исполнения программы, какую функцию вызвать, основываясь на типе объекта. Для разных объектов вызываются разные версии одной и той же виртуальной функции.


**Ellipse**

Класс Ellipse наследуется от базового класса Shape. Обратите внимание что класс Ellipse имеет два приватных поля xRad и yRad, для хранения значений радиусов по x и по y. Конструктор класса принимает два значения и инициализирует ими поля xRad и yRad. Функции area и draw являются перегруженным функциями базового класса Shapes.

Обратите внимание на реализацию этих функций

```cpp
double Ellipse::area() const {
  return PI * xRad * yRad;
}

void Ellipse::draw(Canvas *canvas) const{
  // Перебирает по всем пикселям (x,y) 
  // решетки
  for(int x = 0; x < CANVAS_WIDTH; ++x){
    for(int y = 0; y < CANVAS_HEIGHT; ++y){

      // Элипс содержит точку (x,y) только если
      // ((x-xPos)/xRad)^2 + ((y-yPos)/yRad)^2 <= 1

      double xDiff = x - get_xPos();
      double yDiff = y - get_yPos();

      if( (xDiff/xRad)*(xDiff/xRad) + (yDiff/yRad)*(yDiff/yRad) <= 1 ){
        // Если точка принадлежит элипсу "включаем" пиксель
        canvas->setPixel(x, y, true);
      }
    }
  }
}
```

Рисуя эллипс мы итерируем по всем точка канвы (сетки для отрисовки) и проверяем какие точки принадлежат эллипсу, а какие нет, включая и выключая соответственные пиксели.

**Задачи**

**Circle**

- В файле shapes.h должно быть только объявление класса, а вся реализация в файле shapes.cpp.
- Класс Circle должен наследоваться от базового класса Ellipse (который в свою очередь наследуется от класса Shapes).
- Конструктор Circle должен принимать один аргумент типа double - радиус круга.
- Рассматривайте круг как частный случай эллипса. Класс Circle может быть реализован без объявления новых полей и без переписывания методов.

Измените функцию main в файле lab02.cpp добавьте создание экземпляра Circle с радиусом 3. Установите начальную позицию для круга в (4, 6).  Измените размер массива shapes на 2. Измените тип массива на Shape* (вместо Ellipse *) и добавьте в массив указатель на только что созданные экземпляр Circle.
Так же необходимо изменить тип указателя используемый в цикле.

**Rectangle**

- В файле shapes.h должно быть только объявление класса, а вся реализация в файле shapes.cpp.
- Класс Rectangle должен наследоваться от базового класса Shapes.
- Конструктор должен принимать два аргумента - высоту и ширину.
- В класс необходимо добавить два поля для хранения высоты и ширины.
- Необходимо реализовать функции area и draw.
- Для Rectangle необходимо перегрузить функцию draw по аналогии с функцией draw класса Ellipse - итерируя все пиксели и проверяя каждый на принадлежность примитиву. Для проверки того что точка (x,y) принадлежит прямоугольнику с центром в точке (xPos,yPos) можно воспользоваться следующей формулой:

    > |x - xPos| <= width/2 AND |y - yPos| <= height/2

- Если хотите протестировать работу функции area до того как реализуете функцию draw, просто создайте функцию draw с пустым телом (нужно чтобы компилятор перестал ругаться, так как функция draw чисто виртуальная).

Аналогично, как и для класса Circle измените функцию main и нарисуйте прямоугольник с шириной = 5 и высотой = 3 и начальной точкой в (4, 15).


